import { Pool, QueryResult } from 'pg';
import { Item } from '../../../domain/entities/item.entity';
import { ItemRepository } from '../../../domain/repositories/item.repository.interface';

/**
 * @class PostgresItemRepository
 * @description Implements the ItemRepository interface using PostgreSQL as the data store.
 * This class is responsible for all direct database interactions related to items.
 */
export class PostgresItemRepository implements ItemRepository {
  /**
   * The connection pool to the PostgreSQL database.
   * @private
   * @readonly
   */
  private readonly pool: Pool;

  /**
   * Creates an instance of PostgresItemRepository.
   * @param {Pool} pool - The PostgreSQL connection pool, injected for database communication.
   */
  constructor(pool: Pool) {
    this.pool = pool;
  }

  /**
   * Creates a new item in the database.
   * Assumes the 'id' column is auto-generated by the database (e.g., as a UUID).
   * @param {Omit<Item, 'id'>} itemData - The data for the new item.
   * @returns {Promise<Item>} A promise that resolves to the newly created item.
   */
  async create(itemData: Omit<Item, 'id'>): Promise<Item> {
    const query = 'INSERT INTO items (name, price) VALUES ($1, $2) RETURNING *;';
    const values = [itemData.name, itemData.price];

    const result: QueryResult<Item> = await this.pool.query(query, values);
    return result.rows[0];
  }

  /**
   * Finds a single item by its unique ID from the database.
   * @param {string} id - The unique ID of the item to find.
   * @returns {Promise<Item | null>} A promise that resolves to the found item, or null if not found.
   */
  async findById(id: string): Promise<Item | null> {
    const query = 'SELECT * FROM items WHERE id = $1;';
    const values = [id];

    const result: QueryResult<Item> = await this.pool.query(query, values);
    return result.rows[0] || null;
  }

  /**
   * Retrieves all items from the database.
   * @returns {Promise<Item[]>} A promise that resolves to an array of all items.
   */
  async findAll(): Promise<Item[]> {
    const query = 'SELECT * FROM items ORDER BY name ASC;';
    const result: QueryResult<Item> = await this.pool.query(query);
    return result.rows;
  }

  /**
   * Updates an existing item's data in the database.
   * This method dynamically builds the query to support partial updates.
   * @param {string} id - The unique ID of the item to update.
   * @param {Partial<Omit<Item, 'id'>>} itemData - An object containing the fields to update.
   * @returns {Promise<Item | null>} A promise that resolves to the updated item, or null if the item was not found.
   */
  async update(id: string, itemData: Partial<Omit<Item, 'id'>>): Promise<Item | null> {
    const fields = Object.keys(itemData) as (keyof typeof itemData)[];
    if (fields.length === 0) {
      // If no data is provided to update, find and return the existing item.
      return this.findById(id);
    }
    
    const setClause = fields.map((field, index) => `${field} = $${index + 1}`).join(', ');
    const values = fields.map(field => itemData[field]);
    values.push(id); // Add the id for the WHERE clause

    const query = `UPDATE items SET ${setClause} WHERE id = $${values.length} RETURNING *;`;

    const result: QueryResult<Item> = await this.pool.query(query, values);
    return result.rows[0] || null;
  }

  /**
   * Deletes an item by its unique ID from the database.
   * @param {string} id - The unique ID of the item to delete.
   * @returns {Promise<boolean>} A promise that resolves to true if an item was deleted, false otherwise.
   */
  async deleteById(id: string): Promise<boolean> {
    const query = 'DELETE FROM items WHERE id = $1;';
    const values = [id];

    const result = await this.pool.query(query, values);
    // Use the Nullish Coalescing Operator to safely handle a potential null value for rowCount.
    return (result.rowCount ?? 0) > 0;
  }
}